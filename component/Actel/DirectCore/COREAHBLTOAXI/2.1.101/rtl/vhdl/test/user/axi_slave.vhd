----------------------------------------------------------------------------------------------
--
-- VHDL file generated by X-HDL - Revision 3.2.52  Mar. 28, 2005 
-- Thu Sep  6 12:17:21 2012
--
--      Input file         : Y:/Technical/korpatim/COREAXI/test/user/axi_slave.v
--      Design name        : axi_slave
--      Author             : 
--      Company            : 
--
--      Description        : 
--
--
----------------------------------------------------------------------------------------------
--
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

library work;
use work.xhdl_std_logic.all;
use work.xhdl_misc.all;
use work.coreparameters.all;

ENTITY axi_slave IS
   GENERIC (
      AXI_AWIDTH                     :  integer := 32;    
      AXI_DWIDTH                     :  integer := 64;    
      ID_WIDTH                       :  integer := 4);    
   PORT (
      ACLK                    : IN std_logic;   
      ARESETN                 : IN std_logic;   
      AWID                    : IN std_logic_vector(ID_WIDTH - 1 DOWNTO 0);   
      AWADDR                  : IN std_logic_vector(AXI_AWIDTH - 1 DOWNTO 0);   
      AWLEN                   : IN std_logic_vector(3 DOWNTO 0);   
      AWSIZE                  : IN std_logic_vector(2 DOWNTO 0);   
      AWBURST                 : IN std_logic_vector(1 DOWNTO 0);   
      AWLOCK                  : IN std_logic_vector(1 DOWNTO 0);   
      --AWCACHE                 : IN std_logic_vector(3 DOWNTO 0);   
      --AWPROT                  : IN std_logic_vector(2 DOWNTO 0);   
      AWVALID                 : IN std_logic;  

      WID                     : IN std_logic_vector(ID_WIDTH - 1 DOWNTO 0);
      WDATA                   : IN std_logic_vector(AXI_DWIDTH - 1 DOWNTO 0);
      WSTRB                   : IN std_logic_vector(AXI_DWIDTH / 8 - 1 DOWNTO 0);
      WLAST                   : IN std_logic;
      WVALID                  : IN std_logic;

      ARID                    : IN std_logic_vector(ID_WIDTH - 1 DOWNTO 0);   
      ARADDR                  : IN std_logic_vector(AXI_AWIDTH - 1 DOWNTO 0);   
      ARLEN                   : IN std_logic_vector(3 DOWNTO 0);   
      ARSIZE                  : IN std_logic_vector(2 DOWNTO 0);   
      ARBURST                 : IN std_logic_vector(1 DOWNTO 0);   
      ARLOCK                  : IN std_logic_vector(1 DOWNTO 0);   
      --ARCACHE                 : IN std_logic_vector(3 DOWNTO 0);   
      --ARPROT                  : IN std_logic_vector(2 DOWNTO 0);   
      ARVALID                 : IN std_logic;  
     
      RREADY                  : IN std_logic;
      BREADY                  : IN std_logic;
      --RDATA_TRIGGER           : IN std_logic;

   -- OUTPUTS
      AWREADY                 : OUT std_logic;
      ARREADY                 : OUT std_logic;
      WREADY                  : OUT std_logic;
      BID                     : OUT std_logic_vector(ID_WIDTH - 1 DOWNTO 0);
      BRESP                   : OUT std_logic_vector(1 DOWNTO 0);
      BVALID                  : OUT std_logic;
      RID                     : OUT std_logic_vector(ID_WIDTH - 1 DOWNTO 0);
      RDATA                   : OUT std_logic_vector(AXI_DWIDTH - 1 DOWNTO 0);
      RRESP                   : OUT std_logic_vector(1 DOWNTO 0);
      RVALID                  : OUT std_logic;
      RLAST                   : OUT std_logic
);   
END axi_slave;

ARCHITECTURE translated OF axi_slave IS

   CONSTANT  AXI_STRBWIDTH         :  integer := AXI_DWIDTH / 8;  
   
   TYPE MEM_ARRAY IS ARRAY (20 DOWNTO 0) OF std_logic_vector((AXI_DWIDTH-1) DOWNTO 0);
    
   SIGNAL data_array   : MEM_ARRAY;
   SIGNAL RVALID_int   : std_logic;
   SIGNAL ARREADY_int   : std_logic;
     
BEGIN 


   PROCESS IS

   PROCEDURE reset_axi_rddatachan IS
     BEGIN
      WAIT UNTIL (ACLK'EVENT AND ACLK = '1');
      
      RID <= (OTHERS => '0');    
      RDATA <= X"0000000000000000";
      RRESP <= '0' & '0';    
      RLAST <= '0';    
      RRESP <= '0' & '0';    
      RLAST <= '0';    
      RVALID <= '0';  
      RVALID_int <= '0';  
   END reset_axi_rddatachan;


   PROCEDURE axi_respond_to_read (
     SIGNAL mem_data : IN MEM_ARRAY)IS
   BEGIN
      WAIT UNTIL (ACLK'EVENT AND ACLK = '1');
      
      RID <= (OTHERS => '0');    
      RDATA <= mem_data(to_integer(ARADDR));    
      RRESP <= '0' & '0';    
      RLAST <= '1';    
      RVALID <= '1';
      --RDATA_TRIGGER <= '1';   
      WHILE(RREADY = '0') LOOP
        WAIT UNTIL (ACLK'EVENT AND ACLK = '1');
      end LOOP;
      
      
      reset_axi_rddatachan;   
   END axi_respond_to_read;


  BEGIN

      WAIT UNTIL (ARESETN'EVENT AND ARESETN = '0') OR (ACLK'EVENT AND ACLK = '1');
         RID <= (OTHERS => '0');    
         RDATA <= X"0000000000000000";
         RRESP <= '0' & '0';    
         RLAST <= '0';    
         RVALID <= '0'; 
        IF(ARVALID = '1')THEN
            axi_respond_to_read(data_array);
        END IF ;

      --END IF;
   END PROCESS;

   AWREADY <= '1'; 
   ARREADY <= '1'; 
   WREADY  <= '1'; 

  PROCESS
  BEGIN
     WAIT UNTIL (ACLK'EVENT AND ACLK = '1');
        IF (WVALID = '1') THEN
            data_array(to_integer(AWADDR)) <= WDATA;
        END IF;
  END PROCESS;

  PROCESS
  BEGIN
      WAIT UNTIL (ARESETN'EVENT AND ARESETN = '0') OR (ACLK'EVENT AND ACLK = '1');
      IF (NOT ARESETN = '1') THEN
         BID <= (OTHERS => '0');    
         BRESP <= '0' & '0';    
         BVALID <= '0';    
      ELSE
        --IF ((WLAST = '1' AND WVALID = '1') AND WREADY = '1') THEN
        IF (WLAST = '1' ) THEN
               BID <= (OTHERS => '0');    
               BRESP <= '0' & '0';    
               BVALID <= '1';   
        ELSE 
               BID <= (OTHERS => '0');    
               BRESP <= '0' & '0';    
               BVALID <= '0';   
        END IF;
      END IF;
  END PROCESS;


END translated;
