----------------------------------------------------------------------------------------------
--
-- VHDL file generated by X-HDL - Revision 3.2.52  Mar. 28, 2005 
-- Thu Sep  6 12:17:21 2012
--
--      Input file         : Y:/Technical/korpatim/COREAXI/test/user/axi_slave.v
--      Design name        : axi_slave
--      Author             : 
--      Company            : 
--
--      Description        : 
--
--
----------------------------------------------------------------------------------------------
--
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

library work;
use work.xhdl_std_logic.all;
use work.xhdl_misc.all;
use work.coreparameters.all;

ENTITY axi_slave IS
   GENERIC (
         FAMILY                         :  integer := 19;    
         AXI_DWIDTH                     :  integer := 64;    --  64/128/256
         M0_SLAVE0ENABLE                :  integer := 1;    
         M0_SLAVE1ENABLE                :  integer := 0;    
         M0_SLAVE2ENABLE                :  integer := 0;    
         M0_SLAVE3ENABLE                :  integer := 0;    
         M0_SLAVE4ENABLE                :  integer := 0;    
         M0_SLAVE5ENABLE                :  integer := 0;    
         M0_SLAVE6ENABLE                :  integer := 0;    
         M0_SLAVE7ENABLE                :  integer := 0;    
         M0_SLAVE8ENABLE                :  integer := 0;    
         M0_SLAVE9ENABLE                :  integer := 0;    
         M0_SLAVE10ENABLE               :  integer := 0;    
         M0_SLAVE11ENABLE               :  integer := 0;    
         M0_SLAVE12ENABLE               :  integer := 0;    
         M0_SLAVE13ENABLE               :  integer := 0;    
         M0_SLAVE14ENABLE               :  integer := 0;    
         M0_SLAVE15ENABLE               :  integer := 0;    
         M0_SLAVE16ENABLE               :  integer := 0;    
         M1_SLAVE0ENABLE                :  integer := 1;    
         M1_SLAVE1ENABLE                :  integer := 0;    
         M1_SLAVE2ENABLE                :  integer := 0;    
         M1_SLAVE3ENABLE                :  integer := 0;    
         M1_SLAVE4ENABLE                :  integer := 0;    
         M1_SLAVE5ENABLE                :  integer := 0;    
         M1_SLAVE6ENABLE                :  integer := 0;    
         M1_SLAVE7ENABLE                :  integer := 0;    
         M1_SLAVE8ENABLE                :  integer := 0;    
         M1_SLAVE9ENABLE                :  integer := 0;    
         M1_SLAVE10ENABLE               :  integer := 0;    
         M1_SLAVE11ENABLE               :  integer := 0;    
         M1_SLAVE12ENABLE               :  integer := 0;    
         M1_SLAVE13ENABLE               :  integer := 0;    
         M1_SLAVE14ENABLE               :  integer := 0;    
         M1_SLAVE15ENABLE               :  integer := 0;    
         M1_SLAVE16ENABLE               :  integer := 0;    
         M2_SLAVE0ENABLE                :  integer := 1;    
         M2_SLAVE1ENABLE                :  integer := 0;    
         M2_SLAVE2ENABLE                :  integer := 0;    
         M2_SLAVE3ENABLE                :  integer := 0;    
         M2_SLAVE4ENABLE                :  integer := 0;    
         M2_SLAVE5ENABLE                :  integer := 0;    
         M2_SLAVE6ENABLE                :  integer := 0;    
         M2_SLAVE7ENABLE                :  integer := 0;    
         M2_SLAVE8ENABLE                :  integer := 0;    
         M2_SLAVE9ENABLE                :  integer := 0;    
         M2_SLAVE10ENABLE               :  integer := 0;    
         M2_SLAVE11ENABLE               :  integer := 0;    
         M2_SLAVE12ENABLE               :  integer := 0;    
         M2_SLAVE13ENABLE               :  integer := 0;    
         M2_SLAVE14ENABLE               :  integer := 0;    
         M2_SLAVE15ENABLE               :  integer := 0;    
         M2_SLAVE16ENABLE               :  integer := 0;    
         M3_SLAVE0ENABLE                :  integer := 1;    
         M3_SLAVE1ENABLE                :  integer := 0;    
         M3_SLAVE2ENABLE                :  integer := 0;    
         M3_SLAVE3ENABLE                :  integer := 0;    
         M3_SLAVE4ENABLE                :  integer := 0;    
         M3_SLAVE5ENABLE                :  integer := 0;    
         M3_SLAVE6ENABLE                :  integer := 0;    
         M3_SLAVE7ENABLE                :  integer := 0;    
         M3_SLAVE8ENABLE                :  integer := 0;    
         M3_SLAVE9ENABLE                :  integer := 0;    
         M3_SLAVE10ENABLE               :  integer := 0;    
         M3_SLAVE11ENABLE               :  integer := 0;    
         M3_SLAVE12ENABLE               :  integer := 0;    
         M3_SLAVE13ENABLE               :  integer := 0;    
         M3_SLAVE14ENABLE               :  integer := 0;    
         M3_SLAVE15ENABLE               :  integer := 0;    
         M3_SLAVE16ENABLE               :  integer := 0;    
         ID_WIDTH                       :  integer := 4;    
         --NUM_SLAVE_SLOT                 :  integer := 1;    --  1 - 16
         NUM_MASTER_SLOT                :  integer := 1;    --  1 - 4
         MEMSPACE                       :  integer := 1;    --  0 - 6
         HGS_CFG                        :  integer := 1;    --  1 - 6
         ADDR_HGS_CFG                   :  integer := 1;    --  0 - 1
         SC_0                           :  integer := 0;    
         SC_1                           :  integer := 0;    
         SC_2                           :  integer := 0;    
         SC_3                           :  integer := 0;    
         SC_4                           :  integer := 0;    
         SC_5                           :  integer := 0;    
         SC_6                           :  integer := 0;    
         SC_7                           :  integer := 0;    
         SC_8                           :  integer := 0;    
         SC_9                           :  integer := 0;    
         SC_10                          :  integer := 0;    
         SC_11                          :  integer := 0;    
         SC_12                          :  integer := 0;    
         SC_13                          :  integer := 0;    
         SC_14                          :  integer := 0;    
         SC_15                          :  integer := 0;    
         FEED_THROUGH                   :  integer := 0;
         INP_REG_BUF                    :  integer := 1;
         OUT_REG_BUF                    :  integer := 1;
         RD_ACCEPTANCE                  :  integer := 4);    
   PORT (
      ACLK                    : IN std_logic;   
      ARESETN                 : IN std_logic;   
      AWID                    : IN std_logic_vector(ID_WIDTH + 1 DOWNTO 0);   
      AWADDR                  : IN std_logic_vector(31 DOWNTO 0);   
      AWLEN                   : IN std_logic_vector(3 DOWNTO 0);   
      AWSIZE                  : IN std_logic_vector(2 DOWNTO 0);   
      AWBURST                 : IN std_logic_vector(1 DOWNTO 0);   
      AWLOCK                  : IN std_logic_vector(1 DOWNTO 0);   
      AWCACHE                 : IN std_logic_vector(3 DOWNTO 0);   
      AWPROT                  : IN std_logic_vector(2 DOWNTO 0);   
      AWVALID                 : IN std_logic;  

      WID                     : IN std_logic_vector(ID_WIDTH + 1 DOWNTO 0);
      WDATA                   : IN std_logic_vector(AXI_DWIDTH - 1 DOWNTO 0);
      WSTRB                   : IN std_logic_vector(AXI_DWIDTH / 8 - 1 DOWNTO 0);
      WLAST                   : IN std_logic;
      WVALID                  : IN std_logic;

      ARID                    : IN std_logic_vector(ID_WIDTH + 1 DOWNTO 0);   
      ARADDR                  : IN std_logic_vector(31 DOWNTO 0);   
      ARLEN                   : IN std_logic_vector(3 DOWNTO 0);   
      ARSIZE                  : IN std_logic_vector(2 DOWNTO 0);   
      ARBURST                 : IN std_logic_vector(1 DOWNTO 0);   
      ARLOCK                  : IN std_logic_vector(1 DOWNTO 0);   
      ARCACHE                 : IN std_logic_vector(3 DOWNTO 0);   
      ARPROT                  : IN std_logic_vector(2 DOWNTO 0);   
      ARVALID                 : IN std_logic;  
     
      RREADY                  : IN std_logic;
      BREADY                  : IN std_logic;
      RDATA_TRIGGER           : IN std_logic;

   -- OUTPUTS
      AWREADY                 : OUT std_logic;
      ARREADY                 : OUT std_logic;
      WREADY                  : OUT std_logic;
      BID                     : OUT std_logic_vector(ID_WIDTH + 1 DOWNTO 0);
      BRESP                   : OUT std_logic_vector(1 DOWNTO 0);
      BVALID                  : OUT std_logic;
      RID                     : OUT std_logic_vector(ID_WIDTH + 1 DOWNTO 0);
      RDATA                   : OUT std_logic_vector(AXI_DWIDTH - 1 DOWNTO 0);
      RRESP                   : OUT std_logic_vector(1 DOWNTO 0);
      RVALID                  : OUT std_logic;
      RLAST                   : OUT std_logic
);   
END axi_slave;

ARCHITECTURE translated OF axi_slave IS

   CONSTANT  AXI_STRBWIDTH         :  integer := AXI_DWIDTH / 8;  
   CONSTANT  AXI_AWIDTH            :  integer := 32;     
   TYPE MEM_ARRAY IS ARRAY (1 DOWNTO 0) OF std_logic_vector((AXI_DWIDTH-1) DOWNTO 0);
    
   SIGNAL data_array   : MEM_ARRAY;
   SIGNAL RVALID_int   : std_logic;
   SIGNAL ARREADY_int   : std_logic;
     
BEGIN 


   PROCESS IS

   PROCEDURE reset_axi_rddatachan IS
     BEGIN
      --WAIT UNTIL (ACLK'EVENT AND ACLK = '1');
      
      RID <= (OTHERS => '0');    
      RDATA <= X"0000000000000000";
      RRESP <= '0' & '0';    
      RLAST <= '0';    
      RRESP <= '0' & '0';    
      RLAST <= '0';    
      RVALID <= '0';  
      RVALID_int <= '0';  
   END reset_axi_rddatachan;


   PROCEDURE axi_respond_to_read (
     SIGNAL mem_data : IN MEM_ARRAY)IS
   BEGIN
      WAIT UNTIL (ACLK'EVENT AND ACLK = '1');
      
      RID <= (OTHERS => '0');    
      RDATA <= mem_data(to_integer(ARADDR));    
      RRESP <= '0' & '0';    
      RLAST <= '1';    
      RVALID <= '1';
      --RDATA_TRIGGER <= '1';   
      WHILE(RREADY = '0') LOOP
        WAIT UNTIL (ACLK'EVENT AND ACLK = '1');
      end LOOP;
      
      
      reset_axi_rddatachan;   
   END axi_respond_to_read;


  BEGIN

      WAIT UNTIL (ARESETN'EVENT AND ARESETN = '0') OR (ACLK'EVENT AND ACLK = '1');
         RID <= (OTHERS => '0');    
         RDATA <= X"0000000000000000";
         RRESP <= '0' & '0';    
         RLAST <= '0';    
         RVALID <= '0'; 
        IF(ARVALID = '1')THEN
            axi_respond_to_read(data_array);
        END IF ;

      --END IF;
   END PROCESS;

   AWREADY <= '1'; 
   ARREADY <= '1'; 
   WREADY  <= '1'; 
 --PROCESS
 --BEGIN
 --   WAIT UNTIL (ARESETN'EVENT AND ARESETN = '0') OR (ACLK'EVENT AND ACLK = '1');
 --   IF (NOT ARESETN = '1') THEN
 --      ARREADY <= '0';    
 --   ELSE
 --     ARREADY <= '1';    
 --   END IF;
 --END PROCESS;

  --PROCESS
  --BEGIN
  --   WAIT UNTIL (ARESETN'EVENT AND ARESETN = '0') OR (ACLK'EVENT AND ACLK = '1');
  --   IF (NOT ARESETN = '1') THEN
  --      AWREADY <= '0';    
  --   ELSE
  --       AWREADY <= '1';    
  --   END IF;
  --END PROCESS;

  --PROCESS
  --     VARIABLE i : INTEGER := 0;
  --BEGIN
  --   WAIT UNTIL (ARESETN'EVENT AND ARESETN = '0') OR (ACLK'EVENT AND ACLK = '1');
  --   IF (NOT ARESETN = '1') THEN
  --      WREADY <= '0'; 
  --      i := 0;   
  --   ELSE
  --       WREADY <= '1';
  --      IF (WVALID = '1') THEN
  --          data_array(to_integer(AWADDR)) <= WDATA;
  --          --WRITE("data_array = " & to_hexstring(WDATA));
  --      END IF;
  --      
  --      --i := i + 1;

  --   END IF;
  --END PROCESS;
  PROCESS
  BEGIN
     WAIT UNTIL (ACLK'EVENT AND ACLK = '1');
        IF (WVALID = '1') THEN
            data_array(to_integer(AWADDR)) <= WDATA;
        END IF;
  END PROCESS;

   PROCESS
   BEGIN
      WAIT UNTIL (ARESETN'EVENT AND ARESETN = '0') OR (ACLK'EVENT AND ACLK = '1');
      IF (NOT ARESETN = '1') THEN
         BID <= (OTHERS => '0');    
         BRESP <= '0' & '0';    
         BVALID <= '0';    
      ELSE
	IF(BREADY = '1') THEN
               BID <= (OTHERS => '0');    
               BRESP <= '0' & '0';    
               BVALID <= '0';   
        ELSIF (WLAST = '1' ) THEN
               BID <= (OTHERS => '0');    
               BRESP <= '0' & '0';    
               BVALID <= '1';   
        END IF;
      END IF;
   END PROCESS;



END translated;
