----------------------------------------------------------------------------------------------
--
-- Generated by X-HDL Verilog Translator - Version 4.2.5 May 28, 2012
-- Thu Feb 28 2013 10:05:39
--
--      Input file      : 
--      Component name  : CORESDR_AXI
--      Author          : 
--      Company         : 
--
--      Description     : 
--
--
----------------------------------------------------------------------------------------------

LIBRARY ieee;
   USE ieee.std_logic_1164.all;
   USE ieee.std_logic_unsigned.all;
   use ieee.numeric_std.all;

-- *********************************************************************/ 
-- Copyright (c) 2011 Actel Corporation.  All rights reserved.  
-- 
-- Any use or redistribution in part or in whole must be handled in 
-- accordance with the Actel license agreement and must be approved 
-- in advance in writing.  
--  
-- File : coresdr_axi.v 
--     
-- Description: This module is the top level module for the Local bus version of the
--              SDRAM controller, with an AXI wrapper
--
-- TODO's:
-- - clean up comments
--
-- Changed:
-- - remove FIFO implementation
-- - add suport for 32-bit AxSIZE AXI transactions
-- - do read- and write-splitting for when SDRAM_DQSIZE < AxSIZE
-- - added logic to adjust SDR burst length for unaligned addresses
-- - skip "dead" (DQM[1:0] == 2'b00) sdr beats, to improve throughput
-- - remove dead cycles after sdr burst complete
-- - fixed DQM issue (see SAR 33506), each data word has its own DQM value now
-- - fixed DQM issue (see SAR 33186), DQM derived from WSTRB only during writes
-- - flopped DQ and DQM, added extra cycle to SDR control (for timing)
-- - WRAP burst support (fix for SAR 43393)
--
-- Notes:
--
-- *********************************************************************/ 

ENTITY CORESDR_AXI IS
   GENERIC (
      
      -- -------------------------------------------------------------------
      -- PARAMETERS
      -- -------------------------------------------------------------------
      
      -- top-level parameters
      FAMILY                 : INTEGER := 16;		-- DEVICE FAMILY
      SDRAM_CHIPS            : INTEGER := 8;		-- NUMBER OF CHIP SELECTS
      SDRAM_COLBITS          : INTEGER := 12;		-- NUMBER OF COLUMN BITS
      SDRAM_ROWBITS          : INTEGER := 14;		-- NUMBER OF ROW BITS
      SDRAM_CHIPBITS         : INTEGER := 3;		-- NUMBER OF CHIP SELECT BITS
      SDRAM_BANKSTATMODULES  : INTEGER := 4;		-- NUMBER OF BANK STATUS MODULES
      SDRAM_DQSIZE           : INTEGER := 32;		-- DATA BUS WIDTH
      
      RAS                    : INTEGER                      := 2;		-- Minimum ACTIVE to PRECHARGE
      RCD                    : INTEGER                      := 1;		-- Minimum time between ACTIVATE and READ/WRITE
      RRD                    : INTEGER                      := 1;		-- Minimum time between ACTIVATE to ACTIVATE in different banks
      RP                     : INTEGER                      := 1;		-- Minimum PRECHARGE to ACTIVATE.
      RC                     : INTEGER                      := 3;		-- Minimum ACTIVATE to ACTIVATE in same bank.
      RFC                    : INTEGER                      := 10;		-- Minimum AUTO-REFRESH to ACTIVATE/AUTO-REFRESH in same bank  
      WR                     : INTEGER                      := 2;		-- Minimum delay from write to PRECHARGE
      MRD                    : INTEGER                      := 2;		-- Minimum LOADMODE to ACTIVATE command.
      CL                     : INTEGER                      := 2;		-- Cas latency.
      DELAY                  : INTEGER                      := 6800;		-- Initialization delay
      REF                    : INTEGER                      := 4096;		-- Refresh Period.
      REGDIMM                : INTEGER                      := 0;		-- Registered/Buffered DIMMS
      AUTO_PCH               : INTEGER                      := 0		-- issues read with auto precharge or write with auto precharge [TODO: fix auto_pch passing]
      

   );
   PORT (
      
      -- -------------------------------------------------------------------
      -- TOP-LEVEL SIGNALS
      -- -------------------------------------------------------------------
      
      -- inputs on AXI Interface
      ACLK                   : IN STD_LOGIC;		-- AXI clock
      ARESETN                : IN STD_LOGIC;		-- active low reset
      AWID                   : IN STD_LOGIC_VECTOR(3 DOWNTO 0);		-- write address ID
      AWADDR                 : IN STD_LOGIC_VECTOR(31 DOWNTO 0);		-- write address
      AWLEN                  : IN STD_LOGIC_VECTOR(3 DOWNTO 0);		-- burst length
      AWSIZE                 : IN STD_LOGIC_VECTOR(2 DOWNTO 0);		-- write transfer size (expected to be fixed at 64 bits for G4)
      AWBURST                : IN STD_LOGIC_VECTOR(1 DOWNTO 0);		-- burst type (01 or 10)
      -- write address valid
      -- write ID
      -- write data
      -- write strobe, 1 bit per byte of data
      -- last write in burst
      -- write data valid
      -- response ready
      -- unused
      -- read address
      -- burst length
      -- read transfer size (expected to be fixed at 64 bits for G4)
      -- burst type (01 or 10)
      -- unused
      -- address valid signal
      -- master read ready
      AWLOCK                 : IN STD_LOGIC_VECTOR(1 DOWNTO 0);		-- unused
      AWVALID                : IN STD_LOGIC;
      
      -- Outputs on AXI interface
      AWREADY                : OUT STD_LOGIC;		-- write address ready
      WID                    : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
      WDATA                  : IN STD_LOGIC_VECTOR(63 DOWNTO 0);
      WSTRB                  : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
      WLAST                  : IN STD_LOGIC;
      WVALID                 : IN STD_LOGIC;
      WREADY                 : OUT STD_LOGIC;		-- write data ready
      BREADY                 : IN STD_LOGIC;
      BID                    : OUT STD_LOGIC_VECTOR(3 DOWNTO 0);		-- unused
      BRESP                  : OUT STD_LOGIC_VECTOR(1 DOWNTO 0);		-- write response data: 0 = OKAY, 1 = SLVERR
      BVALID                 : OUT STD_LOGIC;		-- response data valid
      ARID                   : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
      ARADDR                 : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
      ARLEN                  : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
      ARSIZE                 : IN STD_LOGIC_VECTOR(2 DOWNTO 0);
      ARBURST                : IN STD_LOGIC_VECTOR(1 DOWNTO 0);
      ARLOCK                 : IN STD_LOGIC_VECTOR(1 DOWNTO 0);
      ARVALID                : IN STD_LOGIC;
      ARREADY                : OUT STD_LOGIC;		-- read address ready
      RREADY                 : IN STD_LOGIC;
      RID                    : OUT STD_LOGIC_VECTOR(3 DOWNTO 0);		-- unused
      RDATA                  : OUT STD_LOGIC_VECTOR(63 DOWNTO 0);		-- read data
      RRESP                  : OUT STD_LOGIC_VECTOR(1 DOWNTO 0);		-- read response: 0 = OKAY, 1 = SLVERR
      RLAST                  : OUT STD_LOGIC;		-- last read in burst
      RVALID                 : OUT STD_LOGIC;		-- read data valid
      
      -- SDR signals
      SDRCLK                 : OUT STD_LOGIC;
      OE                     : OUT STD_LOGIC;
      SA                     : OUT STD_LOGIC_VECTOR(13 DOWNTO 0);
      BA                     : OUT STD_LOGIC_VECTOR(1 DOWNTO 0);
      CS_N                   : OUT STD_LOGIC_VECTOR(SDRAM_CHIPS - 1 DOWNTO 0);
      DQM                    : OUT STD_LOGIC_VECTOR(SDRAM_DQSIZE / 8 - 1 DOWNTO 0);
      CKE                    : OUT STD_LOGIC;
      RAS_N                  : OUT STD_LOGIC;
      CAS_N                  : OUT STD_LOGIC;
      WE_N                   : OUT STD_LOGIC;
      DQ                     : INOUT STD_LOGIC_VECTOR(SDRAM_DQSIZE - 1 DOWNTO 0)
   );
END CORESDR_AXI;

ARCHITECTURE trans OF CORESDR_AXI IS
   -- -------------------------------------------------------------------
   -- components
   -- -------------------------------------------------------------------

   component CORESDR is
    generic (
        FAMILY                         :  integer := 16;    -- Device Family
        SDRAM_RASIZE    : integer := 31;   -- local address bus size
        SDRAM_CHIPS     : integer := 8;    -- number of chip selects
        SDRAM_COLBITS   : integer := 12;   -- max number of sdram column bits
        SDRAM_ROWBITS   : integer := 14;   -- max number of sdram row bits
        SDRAM_CHIPBITS  : integer := 3;    -- number of encoded chip select bits        
        SDRAM_BANKSTATMODULES : integer := 4 -- number of bank status modules used (in multiples of 4)
    );
 
    port(
         CLK             : in std_logic;
         RESET_N         : in std_logic;                      
         RADDR           : in std_logic_vector (SDRAM_RASIZE-1 downto 0); 
         R_REQ           : in std_logic;                      
         W_REQ           : in std_logic;                      
         B_SIZE          : in std_logic_vector (3 downto 0);
         AUTO_PCH        : in std_logic;
         SD_INIT         : in std_logic;
         RAS             : in std_logic_vector (3 downto 0);
         RCD             : in std_logic_vector (2 downto 0);
         RRD             : in std_logic_vector (1 downto 0);
         RP              : in std_logic_vector (2 downto 0);
         RC              : in std_logic_vector (3 downto 0);
         RFC             : in std_logic_vector (3 downto 0);
         WR              : in std_logic_vector (1 downto 0);
         MRD             : in std_logic_vector (2 downto 0);
         CL              : in std_logic_vector (2 downto 0);
         BL              : in std_logic_vector (1 downto 0);
         DELAY           : in std_logic_vector (15 downto 0);
         REF             : in std_logic_vector (15 downto 0);
         COLBITS         : in std_logic_vector (2 downto 0);
         ROWBITS         : in std_logic_vector (1 downto 0);
         REGDIMM         : in std_logic;
         RW_ACK          : out std_logic;                     
         R_VALID         : out std_logic;                     
         D_REQ           : out std_logic;                     
         W_VALID         : out std_logic;                     
         OE              : out std_logic;              
         SA              : out std_logic_vector (13 downto 0);
         BA              : out std_logic_vector (1 downto 0); 
         CS_N            : out std_logic_vector (SDRAM_CHIPS-1 downto 0); 
         DQM             : out std_logic;
         CKE             : out std_logic;                     
         RAS_N           : out std_logic;
         CAS_N           : out std_logic;
         WE_N            : out std_logic
    );
    end component;

  -- CONSTANTS
  CONSTANT ROWBITS_INT            : INTEGER := SDRAM_ROWBITS - 11;
  CONSTANT COLBITS_INT            : INTEGER := SDRAM_COLBITS - 5;

  CONSTANT AXI_DWIDTH             : INTEGER := 64;		-- data width fixed at 64 bits for G4 (max), actual data width is determined by AxSIZE signal
  CONSTANT AXI_AWIDTH             : INTEGER := 32;		-- address width fixed at 32 bits
  CONSTANT SDRAM_RASIZE           : INTEGER := 31;		-- READ ADDRESS
  
  CONSTANT BL                     : STD_LOGIC_VECTOR(1 DOWNTO 0) := "11";		-- Maximum burst length, 0=1 1=2 2=4 (default) 3=8
  CONSTANT ROWBITS                : STD_LOGIC_VECTOR(1 DOWNTO 0) := std_logic_vector(to_unsigned(ROWBITS_INT, 2));		-- # of row bits on sdram device(s)
  CONSTANT COLBITS                : STD_LOGIC_VECTOR(2 DOWNTO 0) := std_logic_vector(to_unsigned(COLBITS_INT, 3));		-- # of column bits on sdram device(s)
  
  -- derived parameters
  CONSTANT DQM_SIZE               : INTEGER := SDRAM_DQSIZE / 8;		-- one bit per byte
  
  -- axi states
  CONSTANT AXI_IDLE               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0000";		-- idle state
  CONSTANT AXI_RADR               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0001";		-- read axi addressing state
  CONSTANT AXI_WADR               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0010";		-- write axi addressing state
  CONSTANT AXI_RTRN               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0011";		-- read AXI-side transfer state
  CONSTANT AXI_WTRN               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0100";		-- write AXI-side transfer state
  CONSTANT AXI_WRSP               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0101";		-- write response state
  CONSTANT AXI_WREQ               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0110";		-- SDR write request state
  CONSTANT AXI_RREQ               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0111";		-- SDR read request state
  CONSTANT AXI_RSDR               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "1000";		-- SDR read transfer state
  CONSTANT AXI_WSDR               : STD_LOGIC_VECTOR(3 DOWNTO 0) := "1001";		-- SDR write transfer state

   SIGNAL OE_i            : STD_LOGIC;
   SIGNAL SA_i            : STD_LOGIC_VECTOR(13 DOWNTO 0);
   SIGNAL BA_i            : STD_LOGIC_VECTOR(1 DOWNTO 0);
   SIGNAL CS_N_i          : STD_LOGIC_VECTOR(SDRAM_CHIPS - 1 DOWNTO 0);
   SIGNAL DQM_i           : STD_LOGIC_VECTOR(SDRAM_DQSIZE / 8 - 1 DOWNTO 0);
   SIGNAL CKE_i           : STD_LOGIC;
   SIGNAL RAS_N_i         : STD_LOGIC;
   SIGNAL CAS_N_i         : STD_LOGIC;
   SIGNAL WE_N_i          : STD_LOGIC;
   
   SIGNAL len_size_reg    : STD_LOGIC_VECTOR(7 DOWNTO 0);
   
   
   
   -- -------------------------------------------------------------------
   -- internal wires and registers
   -- -------------------------------------------------------------------
   
   -- registered (during ADDRESS phase) AXI control
   SIGNAL AWID_reg        : STD_LOGIC_VECTOR(3 DOWNTO 0);		-- write address ID
   SIGNAL ARID_reg        : STD_LOGIC_VECTOR(3 DOWNTO 0);		-- read address ID
   SIGNAL AWLEN_reg       : STD_LOGIC_VECTOR(3 DOWNTO 0);		-- burst length
   SIGNAL AWSIZE_reg      : STD_LOGIC_VECTOR(2 DOWNTO 0);		-- write transfer size (expected to be fixed at 64 bits for SmartFusion4)
   SIGNAL ARLEN_reg       : STD_LOGIC_VECTOR(3 DOWNTO 0);		-- burst length
   SIGNAL ARSIZE_reg      : STD_LOGIC_VECTOR(2 DOWNTO 0);		-- read transfer size (expected to be fixed at 64 bits for SmartFusion4)
   SIGNAL WSTRB_reg       : STD_LOGIC_VECTOR(7 DOWNTO 0);		-- write strobe, to be registered
   SIGNAL WSTRB_mux       : STD_LOGIC_VECTOR(7 DOWNTO 0);		-- muxed write strobe, depending on transfer size
   
   -- ID outputs
   -- write response ID
   -- read ID
   
   -- registered AXI data buses
   SIGNAL WDATA_reg       : STD_LOGIC_VECTOR(AXI_DWIDTH - 1 DOWNTO 0);		-- write data
   SIGNAL RDATA_reg       : STD_LOGIC_VECTOR(AXI_DWIDTH - 1 DOWNTO 0);		-- read data
   -- read data
   SIGNAL WDATA_mux       : STD_LOGIC_VECTOR(AXI_DWIDTH - 1 DOWNTO 0);		-- muxed write data, depending on transfer size
   
   -- muxed depending on memory bus width
   SIGNAL ARADDR_mux      : STD_LOGIC_VECTOR(AXI_AWIDTH - 1 DOWNTO 0);
   SIGNAL AWADDR_mux      : STD_LOGIC_VECTOR(AXI_AWIDTH - 1 DOWNTO 0);
   
   SIGNAL axi_state       : STD_LOGIC_VECTOR(3 DOWNTO 0);		-- AXI state
   SIGNAL axi_nextstate   : STD_LOGIC_VECTOR(3 DOWNTO 0);		-- AXI next state
   SIGNAL axi_rvalid      : STD_LOGIC;		-- AXI valid address registered
   SIGNAL axi_wvalid      : STD_LOGIC;
   SIGNAL asize           : STD_LOGIC_VECTOR(1 DOWNTO 0);		-- muxed ARSIZE and AWSIZE
   SIGNAL asize_reg       : STD_LOGIC_VECTOR(1 DOWNTO 0);		-- registered AxSIZE
   SIGNAL aburst          : STD_LOGIC_VECTOR(1 DOWNTO 0);
   SIGNAL aburst_reg      : STD_LOGIC_VECTOR(1 DOWNTO 0);
   SIGNAL alen            : STD_LOGIC_VECTOR(3 DOWNTO 0);
   SIGNAL alen_reg        : STD_LOGIC_VECTOR(3 DOWNTO 0);
   --wire [AXI_AWIDTH-1:0] aaddr_mux;          // generic address line for control logic
   
   SIGNAL axi_count       : STD_LOGIC_VECTOR(3 DOWNTO 0);
   SIGNAL sdr_count       : STD_LOGIC_VECTOR(3 DOWNTO 0);		-- SDR burst count
   
   SIGNAL sdr_datain      : STD_LOGIC_VECTOR(SDRAM_DQSIZE - 1 DOWNTO 0);		-- sdram write data
   SIGNAL sdr_datain_reg  : STD_LOGIC_VECTOR(SDRAM_DQSIZE - 1 DOWNTO 0);		-- sdram write data
   SIGNAL sdr_dataout     : STD_LOGIC_VECTOR(SDRAM_DQSIZE - 1 DOWNTO 0);		-- sdram read data
   SIGNAL sdr_dataout_reg : STD_LOGIC_VECTOR(SDRAM_DQSIZE - 1 DOWNTO 0);		-- sdram read data, registered
   SIGNAL dqm_sdr         : STD_LOGIC;		-- sdr mask
   SIGNAL DQM_mux         : STD_LOGIC_VECTOR(7 DOWNTO 0);		-- DQM_mux, selects and inverts
   -- appropriate bits from WSTRB
   
   SIGNAL RADDR           : STD_LOGIC_VECTOR(SDRAM_RASIZE - 1 DOWNTO 0);		-- SDR address
   SIGNAL raddr_reg       : STD_LOGIC_VECTOR(SDRAM_RASIZE - 1 DOWNTO 0);		-- SDR address hold register
   SIGNAL R_REQ           : STD_LOGIC;		-- read request to SDR
   SIGNAL W_REQ           : STD_LOGIC;		-- write request to SDR
   SIGNAL w_req_reg       : STD_LOGIC;		-- generated write request to SDR
   SIGNAL RW_ACK          : STD_LOGIC;		-- r/w acknowledge from SDR
   SIGNAL R_VALID_i       : STD_LOGIC;		-- Read data valid from SDR
   SIGNAL R_VALID         : STD_LOGIC;		-- Read data valid from SDR
   SIGNAL R_VALID_reg     : STD_LOGIC;		-- Read data valid from SDR
   SIGNAL D_REQ           : STD_LOGIC;		-- SDR requesting data on RDATA, next clk cycle
   SIGNAL W_VALID         : STD_LOGIC;		-- Unused- LEGACY
   SIGNAL B_SIZE          : STD_LOGIC_VECTOR(3 DOWNTO 0);
   
   -- registered B_SIZE (muxed)
   SIGNAL B_SIZE_reg      : STD_LOGIC_VECTOR(3 DOWNTO 0);
   
   -- next raddr net
   SIGNAL raddr_next      : STD_LOGIC_VECTOR(SDRAM_RASIZE - 1 DOWNTO 0);
   SIGNAL raddr_incr      : STD_LOGIC_VECTOR(SDRAM_RASIZE - 1 DOWNTO 0);
   
   -- Declare intermediate signals for referenced outputs
   SIGNAL WREADY_xhdl3    : STD_LOGIC;
   SIGNAL RVALID_xhdl1    : STD_LOGIC;
   SIGNAL SDRCLK_xhdl2    : STD_LOGIC;
   SIGNAL OE_xhdl0        : STD_LOGIC;
   
   signal RAS_int        : std_logic_vector(3 downto 0);
   signal RCD_int        : std_logic_vector(2 downto 0);
   signal RRD_int        : std_logic_vector(1 downto 0);
   signal RP_int         : std_logic_vector(2 downto 0);
   signal RC_int         : std_logic_vector(3 downto 0);
   signal RFC_int        : std_logic_vector(3 downto 0);
   signal MRD_int        : std_logic_vector(2 downto 0);
   signal CL_int         : std_logic_vector(2 downto 0);
   signal WR_int         : std_logic_vector(1 downto 0);
   signal DELAY_int      : std_logic_vector(15 downto 0);
   signal REF_int        : std_logic_vector(15 downto 0);
   signal REGDIMM_int    : std_logic;
   signal AUTO_PCH_int   : std_logic;
   
   
BEGIN
   -- Convert the integer to standard logic vector 
   RAS_int <= std_logic_vector( to_unsigned(RAS, 4));
   RCD_int <= std_logic_vector( to_unsigned(RCD, 3));
   RRD_int <= std_logic_vector( to_unsigned(RRD, 2));
   RP_int  <= std_logic_vector( to_unsigned(RP, 3));
   RC_int  <= std_logic_vector( to_unsigned(RC, 4));
   RFC_int <= std_logic_vector( to_unsigned(RFC, 4));
   MRD_int <= std_logic_vector( to_unsigned(MRD, 3));
   CL_int  <= std_logic_vector( to_unsigned(CL, 3));
   WR_int  <= std_logic_vector( to_unsigned(WR, 2));
   DELAY_int  <= std_logic_vector( to_unsigned(DELAY, 16));
   REF_int    <= std_logic_vector( to_unsigned(REF, 16));
   REGDIMM_int  <=  '1' WHEN (REGDIMM = 1) else '0';
   AUTO_PCH_int <=  '1' WHEN (AUTO_PCH = 1) else '0';

   -- Drive referenced outputs
   WREADY <= WREADY_xhdl3;
   RVALID <= RVALID_xhdl1;
   SDRCLK <= SDRCLK_xhdl2;
   OE <= OE_xhdl0;
   
   -- -------------------------------------------------------------------
   -- OUTPUT ASSIGNMENTS
   -- -------------------------------------------------------------------
   
   -- SDR output assignments
   SDRCLK_xhdl2 <= ACLK;		-- SDRCLOCK pass-through
   
   -- Data bus and mask
   DQ(SDRAM_DQSIZE - 1 DOWNTO 0) <= sdr_datain_reg(SDRAM_DQSIZE - 1 DOWNTO 0) WHEN (OE_xhdl0 = '1') ELSE
                                    (OTHERS => 'Z');
   
   -- Mask, using WSTRB, which was registered during address phase
   DQM_i(0) <= (DQM_mux(0) OR dqm_sdr) WHEN (axi_state = AXI_WSDR) ELSE
               dqm_sdr;
   DQM_i(1) <= (DQM_mux(1) OR dqm_sdr) WHEN (axi_state = AXI_WSDR) ELSE
               dqm_sdr;
   
   xhdl4 : IF (SDRAM_DQSIZE > 16) GENERATE
      DQM_i(2) <= (DQM_mux(2) OR dqm_sdr) WHEN (axi_state = AXI_WSDR) ELSE
                  dqm_sdr;
      DQM_i(3) <= (DQM_mux(3) OR dqm_sdr) WHEN (axi_state = AXI_WSDR) ELSE
                  dqm_sdr;
   END GENERATE;
   
   xhdl5 : IF (SDRAM_DQSIZE > 32) GENERATE
      DQM_i(4) <= (DQM_mux(4) OR dqm_sdr) WHEN (axi_state = AXI_WSDR) ELSE
                  dqm_sdr;
      DQM_i(5) <= (DQM_mux(5) OR dqm_sdr) WHEN (axi_state = AXI_WSDR) ELSE
                  dqm_sdr;
      DQM_i(6) <= (DQM_mux(6) OR dqm_sdr) WHEN (axi_state = AXI_WSDR) ELSE
                  dqm_sdr;
      DQM_i(7) <= (DQM_mux(7) OR dqm_sdr) WHEN (axi_state = AXI_WSDR) ELSE
                  dqm_sdr;
   END GENERATE;
   
   -- AS: replaced with RDATA mux for byte alignement
   -- assign RDATA[63:0] = RDATA_reg;
   
   -- only accept addresses when 
   -- a) AXI i/f is in address mode
   -- b) A Valid transfer is present (see axi_rvalid and axi_wvalid signals)
   ARREADY <= '1' WHEN (axi_state = AXI_RADR) ELSE
              '0';
   AWREADY <= '1' WHEN (axi_state = AXI_WADR) ELSE
              '0';
   
   -- accept data as long as we are in transfer phase and have not yet received
   -- all data
   WREADY_xhdl3 <= '1' WHEN ((axi_state = AXI_WTRN) AND (axi_count(3 DOWNTO 0) /= "0000")) ELSE
                   '0';
   
   -- Read data is valid when we are in read transfer mode
   RVALID_xhdl1 <= '1' WHEN ((axi_state = AXI_RTRN) AND (axi_count(3 DOWNTO 0) /= "0000")) ELSE
                   '0';
   RID(3 DOWNTO 0) <= ARID_reg(3 DOWNTO 0) WHEN (RVALID_xhdl1 = '1') ELSE
                      "0000";
   
   -- Write response
   BVALID <= '1' WHEN ((axi_state = AXI_WRSP)) ELSE '0';
   BRESP <= "00" WHEN (axi_state = AXI_WRSP) ELSE
            "01";
   BID <= AWID_reg(3 DOWNTO 0) WHEN (axi_state = AXI_WRSP) ELSE
          "0000";
   
   -- Error if error flag set OR we are not in READ transfer mode
   RRESP <= "00" WHEN (axi_state = AXI_RTRN) ELSE
            "01";
   
   -- Last transfer indicator
   RLAST <= '1' WHEN ((axi_state = AXI_RTRN) AND (axi_count(3 DOWNTO 0) = "0001")) ELSE
            '0';
   
   -- -------------------------------------------------------------------
   -- COMBINATORIAL LOGIC
   -- -------------------------------------------------------------------
   
   -- Data bus
   sdr_dataout(SDRAM_DQSIZE - 1 DOWNTO 0) <= DQ(SDRAM_DQSIZE - 1 DOWNTO 0);
   
   -- AXI Read Data bus repeating
   PROCESS (asize_reg, RDATA_reg)
   BEGIN
      CASE asize_reg(1 DOWNTO 0) IS
         -- 16 bit transfer
         WHEN "01" =>
            RDATA(63 DOWNTO 0) <= (RDATA_reg(15 DOWNTO 0) & RDATA_reg(15 DOWNTO 0) & RDATA_reg(15 DOWNTO 0) & RDATA_reg(15 DOWNTO 0));
         -- 32 bit transfer
         WHEN "10" =>
            RDATA(63 DOWNTO 0) <= (RDATA_reg(31 DOWNTO 0) & RDATA_reg(31 DOWNTO 0));
         -- 64 bit transfer
         WHEN "11" =>
            RDATA(63 DOWNTO 0) <= RDATA_reg(63 DOWNTO 0);
         WHEN OTHERS =>
            RDATA(63 DOWNTO 0) <= RDATA_reg(63 DOWNTO 0);
      END CASE;
   END PROCESS;
   
   
   -- mux DQM input to SDR
   -- AS: added DQM masking / negation 8/24/11
   xhdl6 : IF (SDRAM_DQSIZE = 16) GENERATE
      PROCESS (sdr_count, WSTRB_mux)
      BEGIN
         DQM_mux(7 DOWNTO 2) <= "000000";
         CASE sdr_count(3 DOWNTO 0) IS
            WHEN "0000" =>
               DQM_mux(1 DOWNTO 0) <= (NOT(WSTRB_mux(1)) & NOT(WSTRB_mux(0)));
            WHEN "0001" =>
               DQM_mux(1 DOWNTO 0) <= (NOT(WSTRB_mux(3)) & NOT(WSTRB_mux(2)));
            WHEN "0010" =>
               DQM_mux(1 DOWNTO 0) <= (NOT(WSTRB_mux(5)) & NOT(WSTRB_mux(4)));
            WHEN "0011" =>
               DQM_mux(1 DOWNTO 0) <= (NOT(WSTRB_mux(7)) & NOT(WSTRB_mux(6)));
            WHEN OTHERS =>
               DQM_mux(1 DOWNTO 0) <= (NOT(WSTRB_mux(1)) & NOT(WSTRB_mux(0)));
         END CASE;
      END PROCESS;
      
   END GENERATE;
   xhdl7 : IF (NOT(SDRAM_DQSIZE = 16)) GENERATE
      xhdl8 : IF (SDRAM_DQSIZE = 32) GENERATE
         PROCESS (sdr_count, WSTRB_mux)
         BEGIN
            DQM_mux(7 DOWNTO 4) <= "0000";
            CASE sdr_count(3 DOWNTO 0) IS
               WHEN "0000" =>
                  DQM_mux(3 DOWNTO 0) <= (NOT(WSTRB_mux(3)) & NOT(WSTRB_mux(2)) & NOT(WSTRB_mux(1)) & NOT(WSTRB_mux(0)));
               WHEN "0001" =>
                  DQM_mux(3 DOWNTO 0) <= (NOT(WSTRB_mux(7)) & NOT(WSTRB_mux(6)) & NOT(WSTRB_mux(5)) & NOT(WSTRB_mux(4)));
               WHEN OTHERS =>
                  DQM_mux(3 DOWNTO 0) <= (NOT(WSTRB_mux(3)) & NOT(WSTRB_mux(2)) & NOT(WSTRB_mux(1)) & NOT(WSTRB_mux(0)));
            END CASE;
         END PROCESS;
         
      END GENERATE;
      xhdl9 : IF (NOT(SDRAM_DQSIZE = 32)) GENERATE
         xhdl10 : IF (SDRAM_DQSIZE = 64) GENERATE
            PROCESS (WSTRB_mux)
            BEGIN
               DQM_mux(7 DOWNTO 0) <= (NOT(WSTRB_mux(7)) & NOT(WSTRB_mux(6)) & NOT(WSTRB_mux(5)) & NOT(WSTRB_mux(4)) & NOT(WSTRB_mux(3)) & NOT(WSTRB_mux(2)) & NOT(WSTRB_mux(1)) & NOT(WSTRB_mux(0)));
            END PROCESS;
            
         END GENERATE;
      END GENERATE;
   END GENERATE;
   
   -- -------------------------------------------------------------------
   -- Write strob mapping to DQM
   --
   PROCESS (asize_reg, WSTRB_reg)
   BEGIN
      CASE asize_reg(1 DOWNTO 0) IS
         -- 16 bit transfer
         WHEN "01" =>
            WSTRB_mux(7 DOWNTO 2) <= "000000";
            -- Select between WSTRB[1:0], WSTRB[3:2], WSTRB[5:4] WSTRB[7:6]
            IF (WSTRB_reg(1) = '1' OR WSTRB_reg(0) = '1') THEN
               WSTRB_mux(1 DOWNTO 0) <= WSTRB_reg(1 DOWNTO 0);
            ELSIF (WSTRB_reg(3) = '1' OR WSTRB_reg(2) = '1') THEN
               WSTRB_mux(1 DOWNTO 0) <= WSTRB_reg(3 DOWNTO 2);
            ELSIF (WSTRB_reg(5) = '1' OR WSTRB_reg(4) = '1') THEN
               WSTRB_mux(1 DOWNTO 0) <= WSTRB_reg(5 DOWNTO 4);
            ELSIF (WSTRB_reg(7) = '1' OR WSTRB_reg(6) = '1') THEN
               WSTRB_mux(1 DOWNTO 0) <= WSTRB_reg(7 DOWNTO 6);
            ELSE
               WSTRB_mux(1 DOWNTO 0) <= WSTRB_reg(1 DOWNTO 0);
            END IF;
         -- 32 bit transfer
         WHEN "10" =>
            WSTRB_mux(7 DOWNTO 4) <= "0000";
            -- Select between WSTRB[3:0], WSTRB[7:4]
            IF (WSTRB_reg(3) = '1' OR WSTRB_reg(2) = '1' OR WSTRB_reg(1) = '1' OR WSTRB_reg(0) = '1') THEN
               WSTRB_mux(3 DOWNTO 0) <= WSTRB_reg(3 DOWNTO 0);
            ELSIF (WSTRB_reg(7) = '1' OR WSTRB_reg(6) = '1' OR WSTRB_reg(5) = '1' OR WSTRB_reg(4) = '1') THEN
               WSTRB_mux(3 DOWNTO 0) <= WSTRB_reg(7 DOWNTO 4);
            ELSE
               WSTRB_mux(3 DOWNTO 0) <= WSTRB_reg(3 DOWNTO 0);
            END IF;
         -- 64 bit transfer
         WHEN "11" =>
            WSTRB_mux(7 DOWNTO 0) <= WSTRB_reg(7 DOWNTO 0);
         WHEN OTHERS =>
            WSTRB_mux(7 DOWNTO 0) <= WSTRB_reg(7 DOWNTO 0);
      END CASE;
   END PROCESS;
   
   
   -- mux data input to SDR
   xhdl11 : IF (SDRAM_DQSIZE = 16) GENERATE
      PROCESS (sdr_count, WDATA_reg)
      BEGIN
         CASE sdr_count(3 DOWNTO 0) IS
            WHEN "0000" =>
               sdr_datain(15 DOWNTO 0) <= WDATA_reg(15 DOWNTO 0);
            WHEN "0001" =>
               sdr_datain(15 DOWNTO 0) <= WDATA_reg(31 DOWNTO 16);
            WHEN "0010" =>
               sdr_datain(15 DOWNTO 0) <= WDATA_reg(47 DOWNTO 32);
            WHEN "0011" =>
               sdr_datain(15 DOWNTO 0) <= WDATA_reg(63 DOWNTO 48);
            WHEN OTHERS =>
               sdr_datain(15 DOWNTO 0) <= WDATA_reg(15 DOWNTO 0);
         END CASE;
      END PROCESS;
      
   END GENERATE;
   xhdl12 : IF (NOT(SDRAM_DQSIZE = 16)) GENERATE
      xhdl13 : IF (SDRAM_DQSIZE = 32) GENERATE
         PROCESS (sdr_count, WDATA_reg)
         BEGIN
            CASE sdr_count(3 DOWNTO 0) IS
               WHEN "0000" =>
                  sdr_datain(31 DOWNTO 0) <= WDATA_reg(31 DOWNTO 0);
               WHEN "0001" =>
                  sdr_datain(31 DOWNTO 0) <= WDATA_reg(63 DOWNTO 32);
               WHEN OTHERS =>
                  sdr_datain(31 DOWNTO 0) <= WDATA_reg(31 DOWNTO 0);
            END CASE;
         END PROCESS;
         
      END GENERATE;
      xhdl14 : IF (NOT(SDRAM_DQSIZE = 32)) GENERATE
         xhdl15 : IF (SDRAM_DQSIZE = 64) GENERATE
            PROCESS (WDATA_reg)
            BEGIN
               sdr_datain(63 DOWNTO 0) <= WDATA_reg(63 DOWNTO 0);
            END PROCESS;
            
         END GENERATE;
      END GENERATE;
   END GENERATE;
   
   -- ---------------------------------------------------------------------
   -- AS: fix for SAR 43393 (http://bugzilla/show_bug.cgi?id=43393)
   -- LUT for next raddr generation, based on:
   -- - AWADDR/ARADDR
   -- - AWBURST/ARBURST (WRAP vs. INCR)
   -- - B_SIZE (SDR burst size)
   -- - AWLEN/ARLEN
   
   xhdl16 : IF (SDRAM_DQSIZE = 16) GENERATE
      PROCESS (raddr_reg, B_SIZE_reg)
      BEGIN
         raddr_incr <= raddr_reg + ("000000000000000000000000000" & B_SIZE_reg);
      END PROCESS;
      
      
      PROCESS (aburst_reg, alen_reg, raddr_incr, asize_reg, raddr_reg, B_SIZE_reg)
      BEGIN
         IF (aburst_reg(1 DOWNTO 0) = "10") THEN		-- WRAP burst, need to deal with wrap boundaries
            CASE alen_reg(3 DOWNTO 0) IS
               WHEN "0000" =>
                  -- no wrap boundary
                  raddr_next <= raddr_incr;
               WHEN "0001" =>
                  -- wrap at every 2 locations
                  CASE asize_reg(1 DOWNTO 0) IS
                     WHEN "11" =>
                        IF (raddr_incr(2 DOWNTO 0) = "000") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 3) & "000");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN "10" =>
                        IF (raddr_incr(1 DOWNTO 0) = "00") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 2) & "00");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN "01" =>
                        IF (raddr_incr(0) = '0') THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 1) & '0');
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN OTHERS =>
                        raddr_next <= raddr_incr;
                  END CASE;
               WHEN "0011" =>
                  -- wrap at every 4 locations
                  CASE asize_reg(1 DOWNTO 0) IS
                     WHEN "11" =>
                        IF (raddr_incr(3 DOWNTO 0) = "0000") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 4) & "0000");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN "10" =>
                        IF (raddr_incr(2 DOWNTO 0) = "000") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 3) & "000");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN "01" =>
                        IF (raddr_incr(1 DOWNTO 0) = "00") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 2) & "00");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN OTHERS =>
                        raddr_next <= raddr_incr;
                  END CASE;
               WHEN "0111" =>
                  -- wrap at every 8 locations
                  CASE asize_reg(1 DOWNTO 0) IS
                     WHEN "11" =>
                        IF (raddr_incr(4 DOWNTO 0) = "00000") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 5) & "00000");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN "10" =>
                        IF (raddr_incr(3 DOWNTO 0) = "0000") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 4) & "0000");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN "01" =>
                        IF (raddr_incr(2 DOWNTO 0) = "000") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 3) & "000");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN OTHERS =>
                        raddr_next <= raddr_incr;
                  END CASE;
               WHEN OTHERS =>
                  raddr_next <= raddr_incr;
            END CASE;
         ELSE
            -- INCR burst, straight increment, bro!
            raddr_next <= raddr_reg + ("000000000000000000000000000" & B_SIZE_reg);
         END IF;
      END PROCESS;
      
   END GENERATE;
   xhdl17 : IF (NOT(SDRAM_DQSIZE = 16)) GENERATE
      xhdl18 : IF (SDRAM_DQSIZE = 32) GENERATE
         PROCESS (raddr_reg, B_SIZE_reg)
         BEGIN
            raddr_incr <= raddr_reg + ("000000000000000000000000000" & B_SIZE_reg);
         END PROCESS;
         
         
         PROCESS (aburst_reg, alen_reg, raddr_incr, asize_reg, raddr_reg, B_SIZE_reg)
         BEGIN
            IF (aburst_reg(1 DOWNTO 0) = "10") THEN		-- WRAP burst, need to deal with wrap boundaries
               CASE alen_reg(3 DOWNTO 0) IS
                  WHEN "0000" =>
                     -- no wrap boundary
                     raddr_next <= raddr_incr;
                  WHEN "0001" =>
                     -- wrap at every 2 locations
                     CASE asize_reg(1 DOWNTO 0) IS
                        WHEN "11" =>
                           IF (raddr_incr(1 DOWNTO 0) = "00") THEN
                              raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 2) & "00");
                           ELSE
                              raddr_next <= raddr_incr;
                           END IF;
                        WHEN "10" =>
                           IF (raddr_incr(0) = '0') THEN
                              raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 1) & '0');
                           ELSE
                              raddr_next <= raddr_incr;
                           END IF;
                        WHEN OTHERS =>
                           raddr_next <= raddr_incr;
                     END CASE;
                  WHEN "0011" =>
                     -- wrap at every 4 locations
                     CASE asize_reg(1 DOWNTO 0) IS
                        WHEN "11" =>
                           IF (raddr_incr(2 DOWNTO 0) = "000") THEN
                              raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 3) & "000");
                           ELSE
                              raddr_next <= raddr_incr;
                           END IF;
                        WHEN "10" =>
                           IF (raddr_incr(1 DOWNTO 0) = "00") THEN
                              raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 2) & "00");
                           ELSE
                              raddr_next <= raddr_incr;
                           END IF;
                        WHEN OTHERS =>
                           raddr_next <= raddr_incr;
                     END CASE;
                  WHEN "0111" =>
                     -- wrap at every 8 locations
                     CASE asize_reg(1 DOWNTO 0) IS
                        WHEN "11" =>
                           IF (raddr_incr(3 DOWNTO 0) = "0000") THEN
                              raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 4) & "0000");
                           ELSE
                              raddr_next <= raddr_incr;
                           END IF;
                        WHEN "10" =>
                           IF (raddr_incr(2 DOWNTO 0) = "000") THEN
                              raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 3) & "000");
                           ELSE
                              raddr_next <= raddr_incr;
                           END IF;
                        WHEN OTHERS =>
                           raddr_next <= raddr_incr;
                     END CASE;
                  WHEN OTHERS =>
                     raddr_next <= raddr_incr;
               END CASE;
            ELSE
               -- INCR burst, straight increment, bro!
               raddr_next <= raddr_reg + ("000000000000000000000000000" & B_SIZE_reg);
            END IF;
         END PROCESS;
         
      END GENERATE;
      xhdl19 : IF (NOT(SDRAM_DQSIZE = 32)) GENERATE
         xhdl20 : IF (SDRAM_DQSIZE = 64) GENERATE
            PROCESS (raddr_reg, B_SIZE_reg)
            BEGIN
               raddr_incr <= raddr_reg + ("000000000000000000000000000" & B_SIZE_reg);
            END PROCESS;
            
            
            PROCESS (aburst_reg, alen_reg, raddr_incr, raddr_reg, B_SIZE_reg)
            BEGIN
               IF (aburst_reg(1 DOWNTO 0) = "10") THEN		-- WRAP burst, need to deal with wrap boundaries
                  CASE alen_reg(3 DOWNTO 0) IS
                     WHEN "0000" =>
                        -- no wrap boundary
                        raddr_next <= raddr_incr;
                     WHEN "0001" =>
                        -- wrap at every 2 locations
                        IF (raddr_incr(0) = '0') THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 1) & '0');
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN "0011" =>
                        -- wrap at every 4 locations
                        IF (raddr_incr(1 DOWNTO 0) = "00") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 2) & "00");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN "0111" =>
                        -- wrap at every 8 locations
                        IF (raddr_incr(2 DOWNTO 0) = "000") THEN
                           raddr_next <= (raddr_reg(SDRAM_RASIZE - 1 DOWNTO 3) & "000");
                        ELSE
                           raddr_next <= raddr_incr;
                        END IF;
                     WHEN OTHERS =>
                        raddr_next <= raddr_incr;
                  END CASE;
               ELSE
                  -- INCR burst, straight increment, bro!
                  raddr_next <= raddr_reg + ("000000000000000000000000000" & B_SIZE_reg);
               END IF;
            END PROCESS;
            
         END GENERATE;
      END GENERATE;
   END GENERATE;
   
   -- ---------------------------------------------------------------------
   
   RADDR <= raddr_reg;
   
   -- generate SDR-side read request when AXI requests it
   R_REQ <= '1' WHEN ((axi_state = AXI_RREQ) OR ((axi_state = AXI_RTRN) AND (RREADY = '1'))) ELSE '0';
   
   -- only generate SDR-side write request once data is buffered, or bufferING
   W_REQ <= '1' WHEN ((axi_state = AXI_WREQ) OR ((axi_state = AXI_WTRN) AND (WVALID = '1'))) ELSE '0';
   
   -- AXI transfer only valid if
   -- 1) 64 bit transaction used (which it will be for G4) [AS: removed this condition]
   -- 2) INCR (01) or WRAP (10) tranfer indicated on BURST line
   -- 3) Burst length is less than 8
   -- 4) A[*]VALID signal asserted
   axi_rvalid <= '1' WHEN ((ARVALID = '1') AND ((ARBURST(1 DOWNTO 0) = "01") OR (ARBURST(1 DOWNTO 0) = "10")) AND (ARLEN(3 DOWNTO 0) <= "1000")) ELSE
                 '0';
   axi_wvalid <= '1' WHEN ((AWVALID = '1') AND ((AWBURST(1 DOWNTO 0) = "01") OR (AWBURST(1 DOWNTO 0) = "10")) AND (AWLEN(3 DOWNTO 0) <= "1000")) ELSE
                 '0';
   
   -- generice asize, muxed AxSIZE signals
   asize(1 DOWNTO 0) <= ARSIZE(1 DOWNTO 0) WHEN (ARVALID = '1') ELSE
                        AWSIZE(1 DOWNTO 0) WHEN (AWVALID = '1') ELSE
                        "11";
   
   -- generic alen, muxed AxLEN signals
   alen(3 DOWNTO 0) <= ARLEN(3 DOWNTO 0) WHEN (ARVALID = '1') ELSE
                       AWLEN(3 DOWNTO 0) WHEN (AWVALID = '1') ELSE
                       "0000";
   
   -- generic aburst, muxed AxBURST signals
   aburst(1 DOWNTO 0) <= ARBURST(1 DOWNTO 0) WHEN (ARVALID = '1') ELSE
                         AWBURST(1 DOWNTO 0) WHEN (AWVALID = '1') ELSE
                         "11";
   
   -- generic aaddr, muxed AxADDR signals
   --assign aaddr_mux[31:0] =  (ARVALID == 1'b1) ? ARADDR[31:0] :
   --                          (AWVALID == 1'b1) ? AWADDR[31:0] :
   --                          32'h0000;
   
   -- AXI next state and R/W assignment
   PROCESS (axi_state, axi_rvalid, AWVALID, ARVALID, RW_ACK, axi_count, RREADY, WVALID, BREADY, sdr_count, B_SIZE_reg, R_VALID, W_VALID)
   BEGIN
      CASE axi_state IS
         
         WHEN AXI_IDLE =>
            -- Idle phase
            IF (axi_rvalid = '1') THEN		-- read
               axi_nextstate <= AXI_RADR;
            ELSIF (AWVALID = '1') THEN		-- write
               axi_nextstate <= AXI_WADR;
            ELSE
               axi_nextstate <= AXI_IDLE;
            END IF;
         
         WHEN AXI_RADR =>
            -- AXI read address phase
            IF (ARVALID = '1') THEN
               axi_nextstate <= AXI_RREQ;
            ELSE
               axi_nextstate <= AXI_RADR;
            END IF;
         
         WHEN AXI_WADR =>
            -- AXI write address phase
            IF (AWVALID = '1') THEN
               axi_nextstate <= AXI_WTRN;
            ELSE
               axi_nextstate <= AXI_WADR;
            END IF;
         
         WHEN AXI_RREQ =>
            -- SDR read request generate
            IF (RW_ACK = '1') THEN
               axi_nextstate <= AXI_RSDR;
            ELSE
               axi_nextstate <= AXI_RREQ;
            END IF;
         
         WHEN AXI_WREQ =>
            -- SDR request write operation
            IF (RW_ACK = '1') THEN
               axi_nextstate <= AXI_WSDR;
            ELSE
               axi_nextstate <= AXI_WREQ;
            END IF;
         
         WHEN AXI_RTRN =>
            -- AXI read operation
            -- AS: modified 12/5/11 for SARno 35167 (http://bugzilla/show_bug.cgi?id=35167)
            IF (axi_count(3 DOWNTO 0) = "0001" AND RREADY = '1') THEN
               axi_nextstate <= AXI_IDLE;
            ELSIF (RREADY = '1') THEN
               axi_nextstate <= AXI_RREQ;
            ELSE
               axi_nextstate <= AXI_RTRN;
            END IF;
         
         WHEN AXI_WTRN =>
            -- AXI write operation
            -- Here we will the write FIFO, then generate
            -- the write request
            IF (axi_count(3 DOWNTO 0) = "0000") THEN
               axi_nextstate <= AXI_WRSP;
            ELSIF (WVALID = '1') THEN
               axi_nextstate <= AXI_WREQ;
            ELSE
               axi_nextstate <= AXI_WTRN;
            END IF;
         
         WHEN AXI_WRSP =>
            -- AXI write response
            -- Need a separate cycle after write complete
            IF (BREADY = '1') THEN
               axi_nextstate <= AXI_IDLE;
            ELSE
               axi_nextstate <= AXI_WRSP;
            END IF;
         
         WHEN AXI_RSDR =>
            -- SDR read
            -- AS: this causes isses for SDRAM_DQSIZE == 64,
            --     because we start off with that count
            --     needed to add R_VALID condition to ensure we wait long enough
            IF ((sdr_count(3 DOWNTO 0) = B_SIZE_reg(3 DOWNTO 0) - "0001") AND (R_VALID = '1')) THEN
               axi_nextstate <= AXI_RTRN;
            ELSE
               axi_nextstate <= AXI_RSDR;
            END IF;
         
         WHEN AXI_WSDR =>
            -- SDR write
            -- AS: removed write cycle, needed to add W_VALID condition for
            --     case of SDR_DQSIZE == ARSIZE/AWSIZE width (1 SDR beat per AXI beat)
            IF ((sdr_count(3 DOWNTO 0) = B_SIZE_reg(3 DOWNTO 0) - "0001") AND (W_VALID = '1')) THEN
               IF (axi_count(3 DOWNTO 0) = "0000") THEN
                  axi_nextstate <= AXI_WRSP;
               ELSE
                  axi_nextstate <= AXI_WTRN;
               END IF;
            ELSE
               axi_nextstate <= AXI_WSDR;
            END IF;
         
         WHEN OTHERS =>
            axi_nextstate <= AXI_IDLE;
      END CASE;
   END PROCESS;
   
   
   ----------------------------------------------------------------------
   -- TODO: clean this up!
   -- adjust for unaligned addresses
   -- AS: added 8/24/2011
   -- changes the starting SDR transfer location
   
   -- -------------------------------------------------------------------
   -- Decode burst size AND address mapping
   xhdl21 : IF (SDRAM_DQSIZE = 16) GENERATE
      
      ARADDR_mux <= ('0' & ARADDR(31 DOWNTO 1));
      AWADDR_mux <= ('0' & AWADDR(31 DOWNTO 1));
      
      -- B_SIZE
      PROCESS (asize)
      BEGIN
         CASE asize(1 DOWNTO 0) IS
            WHEN "01" =>
               B_SIZE <= "0001";
            WHEN "10" =>
               B_SIZE <= "0010";
            WHEN "11" =>
               B_SIZE <= "0100";
            WHEN OTHERS =>
               B_SIZE <= "0001";
         END CASE;
      END PROCESS;
      
      
   END GENERATE;
   xhdl22 : IF (NOT(SDRAM_DQSIZE = 16)) GENERATE
      xhdl23 : IF (SDRAM_DQSIZE = 32) GENERATE
         
         ARADDR_mux <= ("00" & ARADDR(31 DOWNTO 2));
         AWADDR_mux <= ("00" & AWADDR(31 DOWNTO 2));
         
         PROCESS (asize)
         BEGIN
            CASE asize(1 DOWNTO 0) IS
               WHEN "10" =>
                  B_SIZE <= "0001";
               WHEN "11" =>
                  B_SIZE <= "0010";
               WHEN OTHERS =>
                  B_SIZE <= "0001";
            END CASE;
         END PROCESS;
         
      END GENERATE;
      xhdl24 : IF (NOT(SDRAM_DQSIZE = 32)) GENERATE
         xhdl25 : IF (SDRAM_DQSIZE = 64) GENERATE
            
            ARADDR_mux <= ("000" & ARADDR(31 DOWNTO 3));
            AWADDR_mux <= ("000" & AWADDR(31 DOWNTO 3));
            
            PROCESS (asize)
            BEGIN
               CASE asize(1 DOWNTO 0) IS
                  WHEN "11" =>
                     B_SIZE <= "0001";
                  WHEN OTHERS =>
                     B_SIZE <= "0001";
               END CASE;
            END PROCESS;
            
         END GENERATE;
      END GENERATE;
   END GENERATE;
   
   -- -------------------------------------------------------------------
   -- Write strobe mapping byte mapping
   --
   PROCESS (asize_reg, WSTRB, WDATA)
   BEGIN
      CASE asize_reg(1 DOWNTO 0) IS
         -- 16 bit transfer
         WHEN "01" =>
            WDATA_mux(63 DOWNTO 16) <= "000000000000000000000000000000000000000000000000";
            
            -- Byte0
            IF (WSTRB(0) = '1') THEN
               WDATA_mux(7 DOWNTO 0) <= WDATA(7 DOWNTO 0);
            ELSIF (WSTRB(2) = '1') THEN
               WDATA_mux(7 DOWNTO 0) <= WDATA(23 DOWNTO 16);
            ELSIF (WSTRB(4) = '1') THEN
               WDATA_mux(7 DOWNTO 0) <= WDATA(39 DOWNTO 32);
            ELSIF (WSTRB(6) = '1') THEN
               WDATA_mux(7 DOWNTO 0) <= WDATA(55 DOWNTO 48);
            ELSE
               WDATA_mux(7 DOWNTO 0) <= "00000000";
            END IF;
            
            -- Byte1
            IF (WSTRB(1) = '1') THEN
               WDATA_mux(15 DOWNTO 8) <= WDATA(15 DOWNTO 8);
            ELSIF (WSTRB(3) = '1') THEN
               WDATA_mux(15 DOWNTO 8) <= WDATA(31 DOWNTO 24);
            ELSIF (WSTRB(5) = '1') THEN
               WDATA_mux(15 DOWNTO 8) <= WDATA(47 DOWNTO 40);
            ELSIF (WSTRB(7) = '1') THEN
               WDATA_mux(15 DOWNTO 8) <= WDATA(63 DOWNTO 56);
            ELSE
               WDATA_mux(15 DOWNTO 8) <= "00000000";
            END IF;
         -- 32 bit transfer
         WHEN "10" =>
            WDATA_mux(63 DOWNTO 32) <= "00000000000000000000000000000000";
            
            -- Byte0 
            IF (WSTRB(0) = '1') THEN
               WDATA_mux(7 DOWNTO 0) <= WDATA(7 DOWNTO 0);
            ELSIF (WSTRB(4) = '1') THEN
               WDATA_mux(7 DOWNTO 0) <= WDATA(39 DOWNTO 32);
            ELSE
               WDATA_mux(7 DOWNTO 0) <= "00000000";
            END IF;
            
            -- Byte1
            IF (WSTRB(1) = '1') THEN
               WDATA_mux(15 DOWNTO 8) <= WDATA(15 DOWNTO 8);
            ELSIF (WSTRB(5) = '1') THEN
               WDATA_mux(15 DOWNTO 8) <= WDATA(47 DOWNTO 40);
            ELSE
               WDATA_mux(15 DOWNTO 8) <= "00000000";
            END IF;
            
            -- Byte2
            IF (WSTRB(2) = '1') THEN
               WDATA_mux(23 DOWNTO 16) <= WDATA(23 DOWNTO 16);
            ELSIF (WSTRB(6) = '1') THEN
               WDATA_mux(23 DOWNTO 16) <= WDATA(55 DOWNTO 48);
            ELSE
               WDATA_mux(23 DOWNTO 16) <= "00000000";
            END IF;
            
            -- Byte3
            IF (WSTRB(3) = '1') THEN
               WDATA_mux(31 DOWNTO 24) <= WDATA(31 DOWNTO 24);
            ELSIF (WSTRB(7) = '1') THEN
               WDATA_mux(31 DOWNTO 24) <= WDATA(63 DOWNTO 56);
            ELSE
               WDATA_mux(31 DOWNTO 24) <= "00000000";
            END IF;
         -- 64 bit transfer
         WHEN "11" =>
            WDATA_mux(63 DOWNTO 0) <= WDATA(63 DOWNTO 0);
         WHEN OTHERS =>
            WDATA_mux(63 DOWNTO 0) <= WDATA(63 DOWNTO 0);
      END CASE;
   END PROCESS;
   
   
   -- -------------------------------------------------------------------
   -- SYNCHRONOUS LOGIC
   -- -------------------------------------------------------------------
   
   -- -------------------------------------------------------------------
   -- Register write data (sdr) and dqm
   PROCESS (ACLK, ARESETN)
   BEGIN
      IF (ARESETN = '0') THEN
         -- reset
         --sdr_dataout_reg <= "00000000000000000000000000000000";
         --sdr_dataout_reg <= "00000000000000000000000000000000";
         sdr_dataout_reg <= (others => '0');
         sdr_datain_reg <= (others => '0');
         DQM <= (others => '0');
         SA <= (others => '0');
         BA <= (others => '0');
         CS_N <= (others => '0');
         CKE <= '0';
         RAS_N <= '0';
         CAS_N <= '0';
         WE_N <= '0';
         OE_xhdl0 <= '0';
         R_VALID <= '0';
      ELSIF (ACLK'EVENT AND ACLK = '1') THEN
         -- posedge clock
         sdr_dataout_reg <= sdr_dataout;
         sdr_datain_reg <= sdr_datain;
         DQM <= DQM_i;
         SA <= (SA_i);
         BA <= (BA_i);
         CS_N <= (CS_N_i);
         CKE <= (CKE_i);
         RAS_N <= (RAS_N_i);
         CAS_N <= (CAS_N_i);
         WE_N <= (WE_N_i);
         OE_xhdl0 <= (OE_i);
         R_VALID_reg <= (R_VALID_i);
         R_VALID <= R_VALID_reg;
      END IF;
   END PROCESS;
   
   
   -- -------------------------------------------------------------------
   -- Register Write Data
   PROCESS (ACLK, ARESETN)
   BEGIN
      IF (ARESETN = '0') THEN
         -- reset
         WDATA_reg(AXI_DWIDTH - 1 DOWNTO 0) <= (OTHERS => '0');
      ELSIF (ACLK'EVENT AND ACLK = '1') THEN
         -- posedge clock
         IF (WVALID = '1' AND WREADY_xhdl3 = '1') THEN
            WDATA_reg(AXI_DWIDTH - 1 DOWNTO 0) <= WDATA_mux(AXI_DWIDTH - 1 DOWNTO 0);
         ELSE
            WDATA_reg(AXI_DWIDTH - 1 DOWNTO 0) <= WDATA_reg(AXI_DWIDTH - 1 DOWNTO 0);
         END IF;
      END IF;
   END PROCESS;
   
   
   -- -------------------------------------------------------------------
   -- Register/Capture Read Data
   -- For 16/32/64 bit data
   
   -- AS: SARno 45369, registered output data
   
   xhdl26 : IF (SDRAM_DQSIZE = 16) GENERATE
      PROCESS (ACLK, ARESETN)
      BEGIN
         IF (ARESETN = '0') THEN
            -- reset
            RDATA_reg(AXI_DWIDTH - 1 DOWNTO 0) <= (OTHERS => '0');
         ELSIF (ACLK'EVENT AND ACLK = '1') THEN
            -- posedge clock
            -- read data present, register it to AXI
            IF (R_VALID = '1') THEN
               CASE sdr_count(1 DOWNTO 0) IS
                  WHEN "00" =>
                     RDATA_reg(15 DOWNTO 0) <= sdr_dataout_reg(15 DOWNTO 0);
                  WHEN "01" =>
                     RDATA_reg(31 DOWNTO 16) <= sdr_dataout_reg(15 DOWNTO 0);
                  WHEN "10" =>
                     RDATA_reg(47 DOWNTO 32) <= sdr_dataout_reg(15 DOWNTO 0);
                  WHEN "11" =>
                     RDATA_reg(63 DOWNTO 48) <= sdr_dataout_reg(15 DOWNTO 0);
                  WHEN OTHERS =>
                     RDATA_reg(15 DOWNTO 0) <= sdr_dataout_reg(15 DOWNTO 0);
               END CASE;
            END IF;
         END IF;
      END PROCESS;
      
   END GENERATE;
   xhdl27 : IF (NOT(SDRAM_DQSIZE = 16)) GENERATE
      xhdl28 : IF (SDRAM_DQSIZE = 32) GENERATE
         PROCESS (ACLK, ARESETN)
         BEGIN
            IF (ARESETN = '0') THEN
               -- reset
               RDATA_reg(AXI_DWIDTH - 1 DOWNTO 0) <= (OTHERS => '0');
            ELSIF (ACLK'EVENT AND ACLK = '1') THEN
               -- posedge clock
               -- read data present, register it to AXI
               IF (R_VALID = '1') THEN
                  CASE sdr_count(0) IS
                     WHEN '0' =>
                        RDATA_reg(31 DOWNTO 0) <= sdr_dataout_reg(31 DOWNTO 0);
                     WHEN '1' =>
                        RDATA_reg(63 DOWNTO 32) <= sdr_dataout_reg(31 DOWNTO 0);
                     WHEN OTHERS =>
                        RDATA_reg(31 DOWNTO 0) <= sdr_dataout_reg(31 DOWNTO 0);
                  END CASE;
               END IF;
            END IF;
         END PROCESS;
         
      END GENERATE;
      xhdl29 : IF (NOT(SDRAM_DQSIZE = 32)) GENERATE
         xhdl30 : IF (SDRAM_DQSIZE = 64) GENERATE
            PROCESS (ACLK, ARESETN)
            BEGIN
               IF (ARESETN = '0') THEN
                  -- reset
                  RDATA_reg(AXI_DWIDTH - 1 DOWNTO 0) <= (OTHERS => '0');
               ELSIF (ACLK'EVENT AND ACLK = '1') THEN
                  -- posedge clock
                  -- read data present, register it to AXI
                  IF (R_VALID = '1') THEN
                     RDATA_reg(63 DOWNTO 0) <= sdr_dataout_reg(63 DOWNTO 0);
                  END IF;
               END IF;
            END PROCESS;
            
         END GENERATE;
      END GENERATE;
   END GENERATE;
   
   -- -------------------------------------------------------------------
   -- AXI state registering
   PROCESS (ACLK, ARESETN)
   BEGIN
      IF (ARESETN = '0') THEN
         -- reset
         axi_state <= AXI_IDLE;
      ELSIF (ACLK'EVENT AND ACLK = '1') THEN
         -- posedge clock
         axi_state <= axi_nextstate;
      END IF;
   END PROCESS;
   
   
   -- -------------------------------------------------------------------
   -- counter and buffer read/write controller
   -- and error generation
   PROCESS (ACLK, ARESETN)
   BEGIN
      IF (ARESETN = '0') THEN
         axi_count(3 DOWNTO 0) <= "0000";
         sdr_count(3 DOWNTO 0) <= "0000";
      ELSIF (ACLK'EVENT AND ACLK = '1') THEN
         -- address phase
         IF (axi_state = AXI_RADR) THEN
            -- AXI decrements
            -- SDR increments
            axi_count(3 DOWNTO 0) <= ARLEN(3 DOWNTO 0) + "0001";
            sdr_count(3 DOWNTO 0) <= "0000";
         ELSIF (axi_state = AXI_WADR) THEN
            axi_count(3 DOWNTO 0) <= AWLEN(3 DOWNTO 0) + "0001";
            sdr_count(3 DOWNTO 0) <= "0000";
         ELSIF (axi_state = AXI_RTRN) THEN
            IF (RREADY = '1') THEN
               axi_count <= axi_count - "0001";
               sdr_count(3 DOWNTO 0) <= "0000";
            END IF;
         ELSIF (axi_state = AXI_WTRN) THEN
            IF (WVALID = '1') THEN
               axi_count <= axi_count - "0001";
               sdr_count(3 DOWNTO 0) <= "0000";
            END IF;
         ELSIF (axi_state = AXI_RSDR) THEN
            -- Valid data present at SDR output
            IF (R_VALID = '1') THEN
               sdr_count <= sdr_count + "0001";
            END IF;
         ELSIF (axi_state = AXI_WSDR OR axi_state = AXI_WREQ) THEN
            -- SDR requests data
            -- AS: W_VALID indicates write has been completed
            --      if (D_REQ == 1'b1)
            IF (W_VALID = '1') THEN
               sdr_count <= sdr_count + "0001";
            END IF;
         ELSIF (axi_state = AXI_RREQ) THEN
            -- read request, hold axi length for now
            axi_count <= axi_count;
         ELSE
            -- AXI_IDLE
            axi_count(3 DOWNTO 0) <= "0000";
            sdr_count(3 DOWNTO 0) <= "0000";
         END IF;
      END IF;
   END PROCESS;
   
   
   -- -------------------------------------------------------------------
   -- AXI control signal registering during address phase
   PROCESS (ACLK, ARESETN)
   BEGIN
      IF (ARESETN = '0') THEN
         -- reset
         B_SIZE_reg(3 DOWNTO 0) <= "0000";
         WSTRB_reg(7 DOWNTO 0) <= "00000000";
         asize_reg(1 DOWNTO 0) <= "00";
         alen_reg(3 DOWNTO 0) <= "0000";
         AWID_reg(3 DOWNTO 0) <= "0000";
         ARID_reg(3 DOWNTO 0) <= "0000";
      ELSIF (ACLK'EVENT AND ACLK = '1') THEN
         -- posedge clock
         IF (axi_state = AXI_IDLE) THEN
            IF ((ARVALID = '1') OR (AWVALID = '1')) THEN
               -- write / read
               IF (AWVALID = '1') THEN
                  AWID_reg(3 DOWNTO 0) <= AWID(3 DOWNTO 0);
               ELSE
                  ARID_reg(3 DOWNTO 0) <= ARID(3 DOWNTO 0);
               END IF;
               
               -- write or read
               -- AS: muxed B_SIZE_registering to account for unaligned addresses
               --B_SIZE_reg[3:0] <= B_SIZE_mux;
               B_SIZE_reg(3 DOWNTO 0) <= B_SIZE;
               asize_reg(1 DOWNTO 0) <= asize(1 DOWNTO 0);
               alen_reg(3 DOWNTO 0) <= alen(3 DOWNTO 0);
               aburst_reg(1 DOWNTO 0) <= aburst(1 DOWNTO 0);
            END IF;
         ELSE
            -- register write strob when write is done
            IF (WVALID = '1' AND WREADY_xhdl3 = '1') THEN
               WSTRB_reg(7 DOWNTO 0) <= WSTRB(7 DOWNTO 0);
            ELSE
               WSTRB_reg(7 DOWNTO 0) <= WSTRB_reg(7 DOWNTO 0);
            END IF;
            -- non-IDLE state, hold
            B_SIZE_reg(3 DOWNTO 0) <= B_SIZE_reg(3 DOWNTO 0);
            asize_reg(1 DOWNTO 0) <= asize_reg(1 DOWNTO 0);
            ARID_reg(3 DOWNTO 0) <= ARID_reg(3 DOWNTO 0);
            AWID_reg(3 DOWNTO 0) <= AWID_reg(3 DOWNTO 0);
         END IF;
      END IF;
   END PROCESS;
   
   
   -- -------------------------------------------------------------------
   -- Register SDR address from AXI address
   -- Control registered separately (above)
   PROCESS (ACLK, ARESETN)
   BEGIN
      IF (ARESETN = '0') THEN
         -- reset
         raddr_reg(SDRAM_RASIZE - 1 DOWNTO 0) <= (OTHERS => '0');
      ELSIF (ACLK'EVENT AND ACLK = '1') THEN
         -- posedge clock
         IF (axi_state = AXI_IDLE) THEN
            IF (ARVALID = '1') THEN
               raddr_reg(SDRAM_RASIZE - 1 DOWNTO 0) <= ARADDR_mux(SDRAM_RASIZE - 1 DOWNTO 0);		-- register read address
            ELSIF (AWVALID = '1') THEN
               raddr_reg(SDRAM_RASIZE - 1 DOWNTO 0) <= AWADDR_mux(SDRAM_RASIZE - 1 DOWNTO 0);		-- register write addres
            ELSE
               raddr_reg(SDRAM_RASIZE - 1 DOWNTO 0) <= (OTHERS => '0');
            END IF;
         ELSIF ((axi_state = AXI_WSDR) OR (axi_state = AXI_RSDR)) THEN
            -- increment address when done current SDR transfer
            -- AS: needed to add these cases for SDRAM_DQSIZE == ARSIZE/AWSIZE width
            IF ((sdr_count(3 DOWNTO 0) = B_SIZE_reg(3 DOWNTO 0) - "0001") AND (W_VALID = '1' OR R_VALID = '1')) THEN
               -- AS: fix for SAR 43393
               -- raddr_reg <= raddr_reg + B_SIZE_reg;
               raddr_reg <= raddr_next;
            END IF;
         ELSE
            raddr_reg(SDRAM_RASIZE - 1 DOWNTO 0) <= raddr_reg(SDRAM_RASIZE - 1 DOWNTO 0);		-- hold
         END IF;
      END IF;
   END PROCESS;
   
   
   -- -------------------------------------------------------------------
   -- INSTANTIATIONS
   -- -------------------------------------------------------------------
   
   -- AS: removed fifos
   
   -- Instantiation SDR controller top level
   
   
   CoreSDR_0 : CORESDR
      GENERIC MAP (
         sdram_rasize           => (SDRAM_RASIZE),
         sdram_chips            => (SDRAM_CHIPS),
         sdram_colbits          => (SDRAM_COLBITS),
         sdram_rowbits          => (SDRAM_ROWBITS),
         sdram_chipbits         => (SDRAM_CHIPBITS),
         sdram_bankstatmodules  => (SDRAM_BANKSTATMODULES)
      )
      PORT MAP (
         clk       => SDRCLK_xhdl2,
         reset_n   => ARESETN,
         raddr     => RADDR,		-- registered and held
         b_size    => B_SIZE_reg,		-- registered and held
         r_req     => R_REQ,
         w_req     => W_REQ,
         auto_pch  => AUTO_PCH_int,
         rw_ack    => RW_ACK,
         d_req     => D_REQ,		-- used for buffer purposes, requests data on the write data bus (datain)
         w_valid   => W_VALID,
         r_valid   => R_VALID_i,
         sd_init   => '0',
         -- run-time init not performed
         ras       => RAS_int,
         rcd       => RCD_int,
         rrd       => RRD_int,
         rp        => RP_int,
         rc        => RC_int,
         rfc       => RFC_int,
         mrd       => MRD_int,
         cl        => CL_int,
         bl        => BL,
         wr        => WR_int,
         delay     => DELAY_int,
         ref       => REF_int,
         colbits   => COLBITS,
         rowbits   => ROWBITS,
         regdimm   => REGDIMM_int,
         sa        => SA_i,
         ba        => BA_i,
         cs_n      => CS_N_i,
         cke       => CKE_i,
         ras_n     => RAS_N_i,
         cas_n     => CAS_N_i,
         we_n      => WE_N_i,
         oe        => OE_i,
         dqm       => dqm_sdr
      );
   
END trans;



